// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Telecom Cloud SDK Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package redis

import (
	"context"
	"encoding/json"
	"encoding/xml"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	cli "github.com/telecom-cloud/client-go/pkg/client"
	"github.com/telecom-cloud/client-go/pkg/common/config"
	"github.com/telecom-cloud/client-go/pkg/common/errors"
	"github.com/telecom-cloud/client-go/pkg/common/utils"
	"github.com/telecom-cloud/client-go/pkg/openapi"
	apiCfg "github.com/telecom-cloud/client-go/pkg/openapi/config"
	apiErr "github.com/telecom-cloud/client-go/pkg/openapi/errors"
	"github.com/telecom-cloud/client-go/pkg/openapi/signer"
	"github.com/telecom-cloud/client-go/pkg/protocol"
	"github.com/telecom-cloud/client-go/pkg/protocol/client"
)

var OptimizeQueryParams = utils.OptimizeQueryParams

type use interface {
	Use(mws ...cli.Middleware)
}

// ResponseResultDecider Definition of global data and types.
type ResponseResultDecider func(*response) error

type (
	bindRequestBodyFunc func(c *HttpClient, r *request) (contentType string, body io.Reader, err error)
	beforeRequestFunc   func(*HttpClient, *request) error
	afterResponseFunc   func(*HttpClient, *response) error
)

var (
	hdrContentTypeKey     = http.CanonicalHeaderKey("Content-Type")
	hdrContentEncodingKey = http.CanonicalHeaderKey("Content-Encoding")

	plainTextType   = "text/plain; charset=utf-8"
	jsonContentType = "application/json; charset=utf-8"
	formContentType = "multipart/form-data"

	jsonCheck    = regexp.MustCompile(`(?i:(application|text)/(json|.*\+json|json\-.*)(;|$))`)
	xmlCheck     = regexp.MustCompile(`(?i:(application|text)/(xml|.*\+xml)(;|$))`)
	formUrlCheck = regexp.MustCompile(`(?i:(application|text)/(x-www-form-urlencoded|.*\+x-www-form-urlencoded)(;|$))`)
)

// Option Configuration of client
type Option struct {
	f func(*Options)
}

type Options struct {
	hostUrl               string
	doer                  client.Doer
	header                http.Header
	requestBodyBind       bindRequestBodyFunc
	responseResultDecider ResponseResultDecider
	cfg                   *apiCfg.OpenapiConfig
	middlewares           []cli.Middleware
	clientOption          []config.ClientOption
}

func GetOptions(ops ...Option) *Options {
	opts := &Options{}
	for _, do := range ops {
		do.f(opts)
	}
	return opts
}

// WithClientOption is used to pass configuration for the crafter client
func WithClientOption(opt ...config.ClientOption) Option {
	return Option{func(op *Options) {
		op.clientOption = append(op.clientOption, opt...)
	}}
}

// WithClientConfig is used to pass openapi configuration for the client
func WithClientConfig(cfg *apiCfg.OpenapiConfig) Option {
	return Option{func(op *Options) {
		op.cfg = cfg
	}}
}

// WithClientMiddleware is used to register the middleware for the crafter client
func WithClientMiddleware(mws ...cli.Middleware) Option {
	return Option{func(op *Options) {
		op.middlewares = append(op.middlewares, mws...)
	}}
}

// WithClient is used to register a custom crafter client
func WithClient(client client.Doer) Option {
	return Option{func(op *Options) {
		op.doer = client
	}}
}

// WithHeader is used to add the default header, which is carried by every request
func WithHeader(header http.Header) Option {
	return Option{func(op *Options) {
		op.header = header
	}}
}

// WithResponseResultDecider configure custom deserialization of http response to response struct
func WithResponseResultDecider(decider ResponseResultDecider) Option {
	return Option{func(op *Options) {
		op.responseResultDecider = decider
	}}
}

func WithHostUrl(HostUrl string) Option {
	return Option{func(op *Options) {
		op.hostUrl = HostUrl
	}}
}

// HttpClient underlying client
type HttpClient struct {
	hostUrl               string
	doer                  client.Doer
	header                http.Header
	cfg                   *apiCfg.OpenapiConfig
	bindRequestBody       bindRequestBodyFunc
	responseResultDecider ResponseResultDecider

	beforeRequest []beforeRequestFunc
	afterResponse []afterResponseFunc
}

func (c *HttpClient) Use(mws ...cli.Middleware) error {
	u, ok := c.doer.(use)
	if !ok {
		return errors.NewPublic("doer does not support middleware, choose the right doer.")
	}
	u.Use(mws...)
	return nil
}

func NewHttpClient(opts *Options) (*HttpClient, error) {
	if opts.requestBodyBind == nil {
		opts.requestBodyBind = defaultRequestBodyBind
	}
	if opts.responseResultDecider == nil {
		opts.responseResultDecider = defaultResponseResultDecider
	}
	if opts.doer == nil {
		cli, err := cli.NewClient(opts.clientOption...)
		if err != nil {
			return nil, err
		}
		opts.doer = cli
	}

	c := &HttpClient{
		hostUrl:               opts.hostUrl,
		doer:                  opts.doer,
		header:                opts.header,
		bindRequestBody:       opts.requestBodyBind,
		responseResultDecider: opts.responseResultDecider,
		beforeRequest: []beforeRequestFunc{
			parseRequestURL,
			parseRequestHeader,
			createHTTPRequest,
		},
		afterResponse: []afterResponseFunc{
			parseResponseBody,
		},
		cfg: opts.cfg,
	}

	if len(opts.middlewares) != 0 {
		if err := c.Use(opts.middlewares...); err != nil {
			return nil, err
		}
	}
	return c, nil
}

func (c *HttpClient) Execute(req *request) (*response, error) {
	var err error
	for _, f := range c.beforeRequest {
		if err = f(c, req); err != nil {
			return nil, err
		}
	}

	if hostHeader := req.header.Get("Host"); hostHeader != "" {
		req.rawRequest.Header.SetHost(hostHeader)
	}

	resp := protocol.Response{}

	err = c.doer.Do(req.ctx, req.rawRequest, &resp)

	response := &response{
		request:     req,
		RawResponse: &resp,
	}

	if err != nil {
		return response, err
	}

	body, err := resp.BodyE()
	if err != nil {
		return nil, err
	}

	if strings.EqualFold(resp.Header.Get(hdrContentEncodingKey), "gzip") && resp.Header.ContentLength() != 0 {
		body, err = resp.BodyGunzip()
		if err != nil {
			return nil, err
		}
	}

	response.bodyByte = body

	response.size = int64(len(response.bodyByte))

	// Apply Response middleware
	for _, f := range c.afterResponse {
		if err = f(c, response); err != nil {
			break
		}
	}

	return response, err
}

// R get request
func (c *HttpClient) R() *request {
	if c.header == nil {
		c.header = http.Header{}
	}
	return &request{
		queryParam:     url.Values{},
		header:         c.header,
		pathParam:      map[string]string{},
		formParam:      map[string]string{},
		fileParam:      map[string]string{},
		client:         c,
		queryEnumAsInt: false,
	}
}

type response struct {
	request     *request
	RawResponse *protocol.Response

	bodyByte []byte
	size     int64
}

// StatusCode method returns the HTTP status code for the executed request.
func (r *response) StatusCode() int {
	if r.RawResponse == nil {
		return 0
	}

	return r.RawResponse.StatusCode()
}

// Body method returns HTTP response as []byte array for the executed request.
func (r *response) Body() []byte {
	if r.RawResponse == nil {
		return []byte{}
	}
	return r.bodyByte
}

// Header method returns the response headers
func (r *response) Header() http.Header {
	if r.RawResponse == nil {
		return http.Header{}
	}
	h := http.Header{}
	r.RawResponse.Header.VisitAll(func(key, value []byte) {
		h.Add(string(key), string(value))
	})

	return h
}

type request struct {
	client         *HttpClient
	url            string
	method         string
	queryEnumAsInt bool
	queryParam     url.Values
	header         http.Header
	pathParam      map[string]string
	formParam      map[string]string
	fileParam      map[string]string
	bodyParam      interface{}
	rawRequest     *protocol.Request
	ctx            context.Context
	requestOptions []config.RequestOption
	result         interface{}
	Error          interface{}
}

func (r *request) SetContext(ctx context.Context) *request {
	r.ctx = ctx
	return r
}

func (r *request) Context() context.Context {
	return r.ctx
}

func (r *request) SetHeader(header, value string) *request {
	r.header.Set(header, value)
	return r
}

func (r *request) AddHeader(header, value string) *request {
	r.header.Add(header, value)
	return r
}

func (r *request) AddHeaders(params map[string]string) *request {
	for k, v := range params {
		r.AddHeader(k, v)
	}
	return r
}

func (r *request) SetQueryParam(param string, value interface{}) *request {
	v := reflect.ValueOf(value)
	switch v.Kind() {
	case reflect.Slice, reflect.Array:
		for index := 0; index < v.Len(); index++ {
			if r.queryEnumAsInt && (v.Index(index).Kind() == reflect.Int32 || v.Index(index).Kind() == reflect.Int64) {
				r.queryParam.Add(param, fmt.Sprintf("%d", v.Index(index).Interface()))
			} else {
				r.queryParam.Add(param, fmt.Sprint(v.Index(index).Interface()))
			}
		}
	case reflect.Int32, reflect.Int64:
		if r.queryEnumAsInt {
			r.queryParam.Add(param, fmt.Sprintf("%d", v.Interface()))
		} else {
			r.queryParam.Add(param, fmt.Sprint(v))
		}
	default:
		r.queryParam.Set(param, fmt.Sprint(v))
	}
	return r
}

func (r *request) SetResult(res interface{}) *request {
	r.result = res
	return r
}

func (r *request) SetError(err interface{}) *request {
	r.Error = err
	return r
}

func (r *request) SetHeaders(headers map[string]string) *request {
	for h, v := range headers {
		r.SetHeader(h, v)
	}

	return r
}

func (r *request) SetQueryParams(params map[string]interface{}) *request {
	for p, v := range params {
		r.SetQueryParam(p, v)
	}

	return r
}

func (r *request) SetPathParams(params map[string]string) *request {
	for p, v := range params {
		r.pathParam[p] = v
	}
	return r
}

func (r *request) SetFormParams(params map[string]string) *request {
	for p, v := range params {
		r.formParam[p] = v
	}
	return r
}

func (r *request) SetFormFileParams(params map[string]string) *request {
	for p, v := range params {
		r.fileParam[p] = v
	}
	return r
}

func (r *request) SetBodyParam(body interface{}) *request {
	r.bodyParam = body
	return r
}

func (r *request) SetRequestOption(option ...config.RequestOption) *request {
	r.requestOptions = append(r.requestOptions, option...)
	return r
}

func (r *request) Execute(method, url string) (*response, error) {
	r.method = method
	r.url = url
	return r.client.Execute(r)
}

func parseRequestURL(c *HttpClient, r *request) error {
	if len(r.pathParam) > 0 {
		for p, v := range r.pathParam {
			r.url = strings.Replace(r.url, ":"+p, url.PathEscape(v), -1)
		}
	}

	// Parsing request URL
	reqURL, err := url.Parse(r.url)
	if err != nil {
		return err
	}

	// If request.URL is relative path then added c.HostURL into
	// the request URL otherwise request.URL will be used as-is
	if !reqURL.IsAbs() {
		r.url = reqURL.String()
		if len(r.url) > 0 && r.url[0] != '/' {
			r.url = "/" + r.url
		}

		reqURL, err = url.Parse(c.hostUrl + r.url)
		if err != nil {
			return err
		}
	}

	// Adding Query Param
	query := make(url.Values)

	for k, v := range r.queryParam {
		// remove query param from client level by key
		// since overrides happens for that key in the request
		query.Del(k)
		for _, iv := range v {
			query.Add(k, iv)
		}
	}

	if len(query) > 0 {
		if isStringEmpty(reqURL.RawQuery) {
			reqURL.RawQuery = query.Encode()
		} else {
			reqURL.RawQuery = reqURL.RawQuery + "&" + query.Encode()
		}
	}

	r.url = reqURL.String()

	return nil
}

func isStringEmpty(str string) bool {
	return len(strings.TrimSpace(str)) == 0
}

func parseRequestHeader(c *HttpClient, r *request) error {
	hdr := make(http.Header)
	if c.header != nil {
		for k := range c.header {
			hdr[k] = append(hdr[k], c.header[k]...)
		}
	}

	for k, v := range r.header {
		hdr.Del(k)
		if len(v) == 0 || v[0] == "" {
			continue
		}
		hdr[k] = append(hdr[k], r.header[k]...)
	}

	if len(r.formParam) != 0 || len(r.fileParam) != 0 {
		hdr.Add(hdrContentTypeKey, formContentType)
	}

	r.header = hdr
	if c.cfg != nil {
		return sign(r, c.cfg)
	}

	return nil
}

func sign(r *request, cfg *apiCfg.OpenapiConfig) error {
	signer := signer.NewOpenApiSigner(cfg.AccessKey, cfg.SecretKey).
		SetRequestId(utils.GetRandomString(32)).
		SetHeader(r.header).
		SetParam(r.queryParam)
	if r.method == http.MethodPost || r.method == http.MethodPut {
		if isFormType(r.header.Get(hdrContentTypeKey)) {
			signer.SetBody(convertToURLValues(r.bodyParam))
		} else {
			body, err := json.Marshal(r.bodyParam)
			if err != nil {
				return err
			}
			signer.SetBody(body)
		}
	}
	header, err := signer.Sign()
	if err != nil {
		return err
	}
	for k, v := range header {
		r.header[k] = v
	}
	return nil
}

// detectContentType method is used to figure out "request.Body" content type for request header
func detectContentType(body interface{}) string {
	contentType := plainTextType
	kind := reflect.Indirect(reflect.ValueOf(body)).Kind()
	switch kind {
	case reflect.Struct, reflect.Map:
		contentType = jsonContentType
	case reflect.String:
		contentType = plainTextType
	default:
		if b, ok := body.([]byte); ok {
			contentType = http.DetectContentType(b)
		} else if kind == reflect.Slice {
			contentType = jsonContentType
		}
	}

	return contentType
}

func defaultRequestBodyBind(c *HttpClient, r *request) (contentType string, body io.Reader, err error) {
	if !isPayloadSupported(r.method) {
		return
	}
	var bodyBytes []byte
	contentType = r.header.Get(hdrContentTypeKey)
	if isStringEmpty(contentType) {
		contentType = detectContentType(r.bodyParam)
		r.header.Set(hdrContentTypeKey, contentType)
	}
	kind := reflect.Indirect(reflect.ValueOf(r.bodyParam)).Kind()
	if isJSONType(contentType) &&
		(kind == reflect.Struct || kind == reflect.Map || kind == reflect.Slice) {
		bodyBytes, err = json.Marshal(r.bodyParam)
	} else if isXMLType(contentType) && (kind == reflect.Struct) {
		bodyBytes, err = xml.Marshal(r.bodyParam)
	} else if isFormType(contentType) {
		bodyBytes = convertToURLValues(r.bodyParam)
	}
	if err != nil {
		return
	}
	return contentType, strings.NewReader(string(bodyBytes)), nil
}

func isPayloadSupported(m string) bool {
	return !(m == http.MethodHead || m == http.MethodOptions || m == http.MethodGet || m == http.MethodDelete)
}

func createHTTPRequest(c *HttpClient, r *request) (err error) {
	contentType, body, err := c.bindRequestBody(c, r)
	if !isStringEmpty(contentType) {
		r.header.Set(hdrContentTypeKey, contentType)
	}
	if err == nil {
		r.rawRequest = protocol.NewRequest(r.method, r.url, body)
		if contentType == formContentType && isPayloadSupported(r.method) {
			if r.rawRequest.IsBodyStream() {
				r.rawRequest.ResetBody()
			}
			r.rawRequest.SetMultipartFormData(r.formParam)
			r.rawRequest.SetFiles(r.fileParam)
		}
		for key, values := range r.header {
			for _, val := range values {
				if val == "" {
					continue
				}
				r.rawRequest.Header.Add(key, val)
			}
		}
		r.rawRequest.SetOptions(r.requestOptions...)
	}
	return err
}

func silently(_ ...interface{}) {}

func defaultResponseResultDecider(res *response) error {
	err := openapi.BindResponse(string(res.bodyByte), res.request.result)
	if err != nil {
		return err
	}

	openapiResp := res.request.result.(*openapi.Response)

	if res.StatusCode() > 400 || openapiResp.ErrorCode != "" || openapiResp.Error != "" {
		if openapiResp.ParseStatusCode() == 800 {
			return nil
		}

		reason := openapiResp.ErrorCode
		if reason == "" {
			reason = openapiResp.Error
		}

		requestId := res.Header().Get("X-Request-Id")

		return &apiErr.StatusError{
			ErrStatus: apiErr.Status{
				RequestId: requestId,
				Code:      int32(openapiResp.ParseStatusCode()),
				Reason:    reason,
				Message:   openapiResp.Message,
			},
		}
	}

	return nil
}

// IsJSONType method is to check JSON content type or not
func isJSONType(ct string) bool {
	return jsonCheck.MatchString(ct)
}

// IsXMLType method is to check XML content type or not
func isXMLType(ct string) bool {
	return xmlCheck.MatchString(ct)
}

func isFormType(ct string) bool {
	return formUrlCheck.MatchString(ct)
}

func convertToURLValues(bodyParam interface{}) []byte {
	vals := url.Values{}
	elem := reflect.ValueOf(bodyParam)
	elem = elem.Elem()
	typ := elem.Type()
	for i := 3; i < typ.NumField(); i++ {
		field := elem.Type().Field(i)
		tag := field.Tag.Get("form")
		if tag == "" {
			tag = field.Name
		}
		switch elem.Field(i).Type().Kind() {
		case reflect.String:
			vals.Add(tag, elem.Field(i).String())
		case reflect.Int32, reflect.Int64:
			vals.Add(tag, strconv.FormatInt(elem.Field(i).Int(), 10))
		case reflect.Uint32, reflect.Uint64:
			vals.Add(tag, strconv.FormatUint(elem.Field(i).Uint(), 10))
		case reflect.Bool:
			vals.Add(tag, strconv.FormatBool(elem.Field(i).Bool()))
		case reflect.Float32, reflect.Float64:
			vals.Add(tag, strconv.FormatFloat(elem.Field(i).Float(), 'f', -1, 64))
		default:
			vals.Add(tag, elem.Field(i).String())
		}
	}

	return []byte(vals.Encode())
}

func parseResponseBody(c *HttpClient, res *response) (err error) {
	if res.StatusCode() == http.StatusNoContent {
		return
	}
	return c.responseResultDecider(res)
}

func JsonMarshal(val interface{}) string {
	if reflect.ValueOf(val).IsNil() {
		return ""
	}
	data, _ := json.Marshal(val)
	return string(data)
}
